* rest-services е архитектура = state = концептоален начин по-който можем да изградим 
комуникация между клиент и сървър и използва http
  - Client-server
  - localhost:3000 това е нашия си сървър на компютъра





* http protokola  = e nachin na formatirane na komunakicia = протокол за комуникиране
HTTP - текстов протокол за пренос на данни
Web-Server = компютър който седи и чака за някаква заявка



* API  =  Приложно-програмен интерфейс - Образно казано, приложно-програмният интерфейс 
предоставя един по-абстрактен и опростен план за разработчика на приложения, 
който би му спестил изучаването на няколко различни слоя от Операционната или 
софтуерната система зад интерфейса.
По този начин се достига ефективност и бързина при адаптирането на нови 




* Encoding = e nachin po koito sa formatirani baitovete v edin file





* URL = там се достъпват ресурсите

----------------------------------------------- JAVASCRIPT -----------------------------------------------
JavaScript е много бърз, защото всички кодови функции могат да се изпълняват веднага, вместо да се налага да се свързват със сървъра и да се чака отговор.
JavaScript може да бъде вмъкнат във всяка уеб страница
Oт netscape е стартиран

Скриптов език - фунционален - динамичен език - интрепетиран - пишем код който ще разберем как работи чак когато го изпълни, 
				другите езици за компилирани(C#, Java) при тях компилатора минава и го превръща в някакъв машинен код
						и той може по време на компилирането да ни каже за някаква грешка


										



няма типове полиморфизам
Има 3-ри scope
		Object
		Function
		Global

Classical OPP - по-принцип се прави с function-s
 

				
----------------------------------------------- AJAX -----------------------------------------------
Какво е AJAX - асинхронен JavaScript / асинхронен начин да прехвърляме текстови данни
AJAX с него правим http request-i през JavaScript

паршел рендеринг - взима се html-a готов

----------------------------------------------- Fetch -----------------------------------------------
Fetch връща response/promise


----------------------------------------------- Promise -----------------------------------------------
JS Applications - Asynchronous Programming - март 2019 - William Abboud
https://www.youtube.com/watch?v=pO54dCLmljQ

Всеки асинхронен код се изпълнява чак когато всеки синхронен код приключи

callbacks e стария вариант, promise и async/await  е новото

В JS асинхронното програмиране е базирано на callbacks
Най често се използват за да вземем някакви данни от сървър

Promise е object - има 3-стадия които може да бъде - Pending/ Fullfile/ Failed
							
somePromise
	.then(() => {    then e method, a другото е callback

	})	


----------------------------------------------- NodeJS -----------------------------------------------
Express е пакет на NodeJS - той е боблиотека която ни позволява да си направим сървър
Сървъра взима всичко което му зададем след localhost:3000/....




----------------------------------------------- CORS -----------------------------------------------

Cross-Origin Resorce Sharing
Cors пази потребителите от атаки

----------------------------------------------- Undefined vs Null -----------------------------------------------
и двете представляват празна стойност

Undefined - означава, че е деклариарана някаква променлива, но още не сме и дали стойност
Null - празно, не сме му задали никаква стойност


----------------------------------------------- Inheritance ------------------------------------------------------
https://www.youtube.com/watch?time_continue=1&v=mDNr_13sbD8

							NULL
						       OBJECT
			ВСИЧКО НАДОЛУ СА ОБЕКТИ КОИТО НАСЛЕДЯВАТ ПРОТОТИПА НА OBJECT
Какво преставлява наследяването - референция към прототипа на горния
Да преизползваме някаква логика от един клас в друг клас
							

C#/Java -  работят с class - class-a играе ролята на шаблон(template)
Javascript  - работи с prototype, ако в parent-a се промени нещо се променя и в нашия обект - референциите са живи

MIXIN - даден class да има достъп до друг class но без да го наследява

__Proto__  - реферира протипа който си наследил  - prototp - което идва от парента
Prototype - e нашия прототип - какво екзполваш към наследниците

hasOwnProperty - проверява текущия obect за някакво property - не се качва нагоре по prototype-chain-a

----------------------------------------------- Prototyp Chain ------------------------------------------------------

имаме достъп до ресурсите с които разполагат нашите прототипи

-----------------------------------------------  Objects ------------------------------------------------------
Object.create - създава празен object и неговия prototype ще е това което сме му подали
всеки обект си има prototype - __PROTO__
super - се използва когато искаме да вземем нещо от parent-a


----------------------------------------------- Classes -----------------------------------------------
New - се случват 5-неща - информарцията се сетва вътре в обекта на 1-во ниво а не в неговия прототип
Разделят се на - 
		01. - Expressions
		02. - Declarations

Abstract class - използва се само за наследяване

Prototype -  е към наследниците
__proto__ - каквото идва от parent-a

01. - Функциите на самия class се закачат на prototyp-a отдолу

Самият Class е един шаблон

class Teacher extends Person {  extends - закача функциите
  constructor(firstName, lastName, email, subject){
    super(firstName, lastName, email);  super - закача нужните пропъртита - вика constructor-a на Person
    this.subject = subject;
  };



----------------------------------------------- THIS -----------------------------------------------
Този обект който седи зад функцията - той и е This-a  -- това при Arrow-Func не важи
При Arrow-Func - няма собсвен контекст  - взима контекста на своя родител

	01 - зависи от къде го извикваме  - invocation
	02 - и начина по-който го извикваме - execution
								5-начина
							01 - event-hander - this-a e към елемента на който сме кликнали(към target-a)
							02 - Kогато е във функция -  global в node.js и window когато е в browser-a
							03 - Object - сочи към самия object
							04 - Call/Apply - сменяме контекста - подаваме какъв да ни е this-a
							05 - Bind - тя няма контекцт, създава нова function и я връща като резултат - с фиксиран контектс на функцията

----------------------------------------------- Function ------------------------------------------------------
https://softuni.bg/trainings/2248/js-advanced-february-2019/internal#lesson-10570
https://www.youtube.com/watch?v=DlReXNJAbp4

Funtions - има само PROTOTYPE a ne __PROTO__

First Class Functions - функция която работи като променлива
Immutable - тази стойност не може да бъде презаписана
CallBack - свършва работа и вика func
void - са функции които не връщат резултат - празно пространство
Arrow-functions - конкретниа контекст


		

Примитивни данни в JS -> 	01. - string
				02. - number
				03. - boolean
				04. - undefined
				05. - null
				06. - Symbol


				

* Closure - тази функционалност въпреки че е извикала само веднъж, вътрещните и функции продължават да имат достъп до горния скоуп
		- функция която има локален контекст който можем да го използваме



* променливите които ползваме в програмирането се делят на две карегории 
		1. - тези които се подават по стойност(Value Types) - number, string boolean,NaN, null, undefined ->  копират стойността -> имат различни адреси в паметта
		2. - тези които се подават по референция(Reference) - Array, Objects, Func -> сочат към един и същ адрес в паметта


Stack - парчето памет което винаги варира и е ограничено се нарича - steck -> там се запазват функциите
Heap - е парче много по-голямо от Stack-a - в него се пазят адреси за обекти -> там са array, object i t.n.

arguments - ползваме го за да вземем всички параметри на функцията, независимо колко са на брой.

Destructuring [...arr] -> заделясе ново парче памет в паметта

Има 3-ри различни начина да декларираме една функция - 
							declaration(hoisting), 
							expression(not hoisting), 
							arrow

Higher-Order Functions - приемат func или връща func или двете = setTimeOut/map/filter/reduce/forEach ....




IIFE - функция която в момента в който се декларира се изпълнява нейното съдържание - енкапулация

Patterns - шаблони

има 4-ри контекста които може да се изпълни една фънкция
 - глобален скоуп
 - метод скоуп - сочи към обекта
 - евент скоуп който сочи към дом елемента
 - и нашия скоуп който го определяме с call/apply/bind


statement - твърдение
function myFunc(word){
	console.log('something ' + word)
}


Curryng  - идеята е да се вземе една Function която приема много параметри и да я разбием на поредица от функции които приемат само един параметър.
Partial Applications - 

----------------------------------------------- Arrow Functions -----------------------------------------------

Arrow Func - няма prototype



				
----------------------------------------------- Променливи ------------------------------------------------------
използва ме ги да пазим някакви стойности

const - несе променя
var - function scope - тя се хоиства - тя е жива от началото на scope до края
let - block scope - локална от 2015 ES6

----------------------------------------------- "==" vs "===" ------------------------------------------------------
"==" compares value only
"==" compares value and type

----------------------------------------------- HTML/CSS ------------------------------------------------------

https://lukyvj.github.io/family.scss/

https://fontawesome.com/cheatsheet?from=io
https://fontawesome.com/icons/angle-down?style=solid
https://fonts.google.com/

difference between inline and inline-block   - на inline-block можем да му даваме padding and margin

vw/vh всеедно използваме проценти но те се взимат от view porta    video - https://www.youtube.com/watch?time_continue=3284&v=T3dUVbVpeXs 55min
% - са за parent-a

padding с %-ти винаги се отнася към width на parent елемента

display: block - взима целия width който може да вземе добавят нов ред преди тях и след тях
display: inline - елелемнти които вървят заедно с текста - нямат hight and width
display: inline-block - позволява да използваме пропъртитата на нашите елементи без да минаваме на нови редове



HTML - текстов документ - език за маркиране с който можем да създаваме и визоализираме web съдържание
CSS - текстов документ

FLOAT - примерно картинка и около нея да има текст


position: relative - позиционира се спрямо себе си
position: absolute - позиционира се спрямо цялото body
position: fixed - позиционира се спрямо viewporta
FLEXBOX CONTAINERS PROPERTIES
												FLEX
 - display: fleks;
 - flex-directions: row | row-reverse| column | column-reverse 
 - flex-wrap: row wrap | wrap | wrap-reverse
 - flex-flow: flex-direction | flex-wrap
 - justify-content: fleks-start | flex-end | center | space-between | space-around | space-evenly
	как се алайват елементите по хоризонтала
 - align-items: flex-start | flex-end | center | baseline | strech
	по вертикала	
 - align-content: flex-start | flex-end | center | space-between | space-between | strech
 	за самото съдържание
 

	ITEMS PROPERTIES
 - order: <integer> както си искаме може да ги пренареждаме
 - flex-grow: <number> - задаване на място
 - flex-shrink: <number> - ако се наложи може да се смалява
 - flex-basis: <number> - основния размер
 - flex-none | flex-grow flex-shrink | flex-basis
 - align-self: auto | flex-start | flex-end | center | baseline | stretch
 
 
 
												GRID
http://grid.malven.co/
grid-gab - разтояние между колони и редовве



												SASS
												
												https://sass-lang.com/guide
												https://devhints.io/sass
												
config sass 
		01 - sass style.sass:style.css
		02 - sass --watch style.scss:style.css
												
pre-processor
дру език който помпилира css
спестява дуплициране на код						
browser-a не знае какво е Sass						
								
								
$testdemo - променлива	
		

nesting
		site {
			&-header {					
				display.block;
			}
		}

								
												
												
												























TYPOGRAPHY - техниката с която се подрежда някакъв писмен език.

margin-bottom - отстояние отдолу на текста
line-height - отстоянието между редовете
font-family - група от шрифтове
1em - е същото да кажем 100% от parenta -> лекция - https://www.youtube.com/watch?time_continue=1321&v=S8Zfo58QRAY
rem - 100% от root елемента				2:02:01 запис



----------------------------------------------- Unit Test ------------------------------------------------------


Types errors
	- Syntax error - нямаме в JS
	- Runtime error
	- Logical error

try  catch  - дават грешка, но не спират програмата
throw new error - дават грешка и спират програмата

----------------------------------------------- MODULES ------------------------------------------------------
JavaScript обекти групираме дадена функционалност
дават ни възможност да скрием информация
глобалния скоуп трябва да е възможно най-малък

има 3 вида модули:
			IIFE - data hiding - неща които не са достъпни от глобалния скоуп
			NodeJS - require/export
			Using ES2015 import/export


----------------------------------------------- ReactJS ------------------------------------------------------
JavaScript библиотека за user interface
Цялата му философия е за създаването на компоненти - компонент патърн

ReactDom - служи да вкара нашето приложение в browser-a
Pure Func - оперира само по параметрите но неги променя, и е нужно да прави само 1-но нещо

Props - всеки компонент има props - той е механизма който подава аргументи - обект който му закачаме key

LifeCycle - как може да маниполираме живота на един компонент - има 3-ри фази - Mount/Update/Dismount

getDerivedStateFromProps - намя this - ако искаме нашия state да зависи от външния свят(от prop-вете) - той се грижи да синхронизира state и prop-вете
shouldComponentUpdate - връща true or false дали да рендерираме
componentDidUpdate - в update фазата - да се направи страничен ефект - базиран на промяната на props или state - винаги се вика някакъв if
componentWillUnmount - ако искаме примерно да запазим нещо в localStorage
		
						Forms
Form полетата в Dom-a си пазят собствения state

Има 2-ва начина който се работи с React	
					- controller - пазим информацията от полето в state
					- ref
					
----------------------------------------------- GIT ------------------------------------------------------
GIT - Система за sors-control

Gulp - инструмент за автоматизация, гледа нашите css файлове и рестартира страницата

content manager system - CMS
jekyll - събира пърчета код и генерира html файлове
jekyll new demo
bundle exec jekyll serve
jekyll serve



----------------------------------------------- GitHub ------------------------------------------------------


git init - за ново repository
touch index.html - create files
git add .
git commit -m "added"
git checkout index.html - да върнем всичко както си е било

git rm index.html- delete files
git remote -v
git rm -r test- delete folder

cat index.html - проверка на index.html
git commit -am "add h2 in body" - това е само за файловете който ги знае
ls -la - показва всичките файлове
git log - може да ходим по историята на проекта

$ git push origin master --force

rm -rf .git delete Git tracking from project







	













